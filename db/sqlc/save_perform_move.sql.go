// Code generated by sqlc. DO NOT EDIT.
// source: save_perform_move.sql

package dbsqlc

import (
	"context"
)

const savePerformMove = `-- name: SavePerformMove :many

WITH last_move AS (
  SELECT COALESCE(max(move_number), 0) last_move_number
  FROM history WHERE game_id = $1
), inserted_moves AS (
  INSERT INTO move (
    old_pile_num,
    old_pile_index,
    old_pile_position,
    new_pile_num,
    new_pile_index,
    new_pile_position
  )
  SELECT UNNEST($2) AS old_pile_num,
    UNNEST($3) AS old_pile_index,
    UNNEST($4) AS old_pile_position,
    UNNEST($5) AS new_pile_num,
    UNNEST($6) AS new_pile_index,
    UNNEST($7) AS new_pile_position
  RETURNING id AS move_id
)
INSERT INTO history (game_id, move_id, move_number)
SELECT $1, last_move_number, move_id
FROM last_move, inserted_moves
RETURNING game_id, move_id
`

type SavePerformMoveParams struct {
	GameID           int64
	OldPileNums      interface{}
	OldPileIndexes   interface{}
	OldPilePositions interface{}
	NewPileNums      interface{}
	NewPileIndexes   interface{}
	NewPilePositions interface{}
}

type SavePerformMoveRow struct {
	GameID int64
	MoveID int64
}

// Make a move.
func (q *Queries) SavePerformMove(ctx context.Context, arg SavePerformMoveParams) ([]SavePerformMoveRow, error) {
	rows, err := q.db.Query(ctx, savePerformMove,
		arg.GameID,
		arg.OldPileNums,
		arg.OldPileIndexes,
		arg.OldPilePositions,
		arg.NewPileNums,
		arg.NewPileIndexes,
		arg.NewPilePositions,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SavePerformMoveRow
	for rows.Next() {
		var i SavePerformMoveRow
		if err := rows.Scan(&i.GameID, &i.MoveID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
