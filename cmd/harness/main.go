package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type mustWriter struct {
	w     io.Writer
	total int64
}

func (m *mustWriter) Printf(format string, a ...interface{}) {
	n, err := fmt.Fprintf(m.w, format, a...)
	if err != nil {
		log.Fatal(err)
	}
	m.total += int64(n)
}

type Method struct {
	Interface string
	Name      string
	Type      string
}

type Harness Method

func (h Harness) WriteTo(w io.Writer) (int64, error) {
	mw := mustWriter{w: w}
	mw.Printf(`

type %s []struct {
	Desc    string
	Input   poc.%s
	Command poc.%s
	Error   ErrorChecker
	Result  %sChecker
}

func (h %s) Run(t *testing.T){
	for _, testCase := range h {
		t.Run(testCase.Desc, func(t *testing.T){
			result, err := testCase.Command.%s(context.Background(), testCase.Input)
			if testCase.Error != nil {
				testCase.Error.CheckError(t, "error", err)
			}
			if testCase.Result != nil {
				testCase.Result.Check%s(t, "", result)
			}
		})
	}
}`, h.Type, h.Type, h.Interface, h.Type, h.Type, h.Name, h.Type)
	return mw.total, nil
}

func (h Harness) Read([]byte) (int, error) {
	return 0, errors.New("not implemented")
}

type Interface Method

func (i Interface) WriteTo(w io.Writer) (int64, error) {
	mw := mustWriter{w: w}
	mw.Printf(`

type %sChecker interface {
	Check%s(*testing.T, string, poc.%s)
}`, i.Type, i.Type, i.Type)
	return mw.total, nil
}

func (i Interface) Read([]byte) (int, error) {
	return 0, errors.New("not implemented")
}

func commandServiceObjects(parent string, decls []ast.Decl) []Method {
	var methods []Method

	for _, val := range decls {
		decl, ok := val.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range decl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			it, ok := ts.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}
			method := Method{Interface: ts.Name.Name}
			for _, field := range it.Methods.List {
				method.Name = field.Names[0].Name
				for _, param := range field.Type.(*ast.FuncType).Params.List {
					id, ok := param.Type.(*ast.Ident)
					if !ok {
						continue
					}
					method.Type = id.Name
				}
			}
			methods = append(methods, method)
		}
	}
	return methods
}

func parse(filename string) *ast.File {
	result, err := parser.ParseFile(token.NewFileSet(), filename, nil, 0)
	if err != nil {
		log.Fatal(err)
	}
	return result
}

var header = `// Code generated by cmd/harness; DO NOT EDIT.

package harness

import (
	"context"
	"testing"

	"github.com/slcjordan/poc"
)`

var errorChecker = `

type ErrorChecker interface {
	CheckError(*testing.T, string, error)
}`

func layout(methods []Method) []io.Reader {
	var result []io.Reader

	result = append(result, strings.NewReader(header))
	result = append(result, strings.NewReader(errorChecker))

	for _, m := range methods {
		result = append(result, Interface(m))
		result = append(result, Harness(m))
	}
	return result
}

func main() {
	var filename string
	flag.StringVar(&filename, "filename", "", "")
	flag.Parse()
	objs := commandServiceObjects("", parse(filename).Decls)
	readers := layout(objs)

	base := filepath.Base(filename)
	file, err := os.Create(filepath.Join("test/harness", base))
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	for _, r := range readers {
		_, err := io.Copy(file, r)
		if err != nil {
			log.Fatal(err)
		}
	}
}
